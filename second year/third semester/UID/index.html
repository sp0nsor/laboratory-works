<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" href="./styles/normalize.css">
  <link rel="stylesheet" href="./styles/theme.css">
  <link rel="stylesheet" href="./styles/style.css">
  <title>PHP story</title>
</head>
<body>
<header class="header">
    <h1>PHP</h1>
</header>
<aside class="sidebar__item">
    <ul class="sider_list">
        <li class="sidebar_item"><a href="#history">История</a></li>
        <li class="sidebar_item"><a href="#review">Обзор</a></li>
        <li class="sidebar_item"><a href="#code">Примеры кода</a></li>
    </ul>

</aside>
<div class="container">
    <figure class="history__owner">
        <img src="./img/Wikirl.jpg" alt="history__owner" class = "img__1">
        <figcaption>Cоздатель</figcaption>
    </figure>
    <selection class="history" id="history">
        <h2 class="history__heading">История</h2>
        <div class="history_twxt">

            <p>В 1994 году датский прогрёаммист <a href="https://ru.wikipedia.org/wiki/Лердорф,_Расмус" target="_blank">Расмус Лердорф</a> разработал на C[16] набор CGI-скриптов для учёта посетителей его онлайн-резюме, обрабатывающий шаблоны HTML-документов. Лердорф назвал набор Personal Home Page Tools (Инструменты для личной домашней страницы). Вскоре функциональности перестало хватать, и Лердорф разработал новый интерпретатор шаблонов PHP/FI (англ. Personal Home Page / Forms Interpreter — «персональная домашняя страница / интерпретатор форм»)[17].

8 июня 1995 года вышел Personal Home Page (PHP Tools) version 1.0 — первый публичный релиз.

В 1997 году после длительного бета-тестирования вышла вторая версия обработчика, написанного на C — PHP/FI 2.0. Её использовали около 1 % (приблизительно 50 тысяч) всех интернет-доменов мира[11].

Версия PHP 3.0 подверглась значительной переработке, определившей современный облик и стиль языка программирования. В 1997 году два израильских программиста, Энди Гутманс и Зеев Сураски, полностью переписали код интерпретатора. PHP 3.0 был официально выпущен в июне 1998 года[11].

Одной из сильнейших сторон PHP 3.0 была возможность расширения ядра дополнительными модулями.</p>


<p> Впоследствии интерфейс написания расширений привлёк к PHP множество сторонних разработчиков, работающих над своими модулями, что дало PHP возможность работать с огромным количеством баз данных, протоколов, поддерживать большое число API. Большое количество разработчиков привело к быстрому развитию языка и стремительному росту его популярности. С этой версии акроним php расшифровывается как «PHP: hypertext Preprocessor», вместо устаревшего «Personal Home Page».

К зиме 1998 года, практически сразу после официального выхода PHP 3.0, Энди Гутманс и Зеев Сураски начали переработку ядра PHP. В задачи входило увеличение производительности сложных приложений и улучшение модульности базиса кода PHP. Новый движок, названный Zend Engine, успешно справлялся с поставленными задачами и впервые был представлен в середине 1999 года. PHP 4.0, основанный на этом движке и принёсший с собой набор дополнительных функций, официально вышел в мае 2000 года. В дополнение к улучшению производительности, PHP 4.0 имел ещё несколько ключевых нововведений, таких как поддержка сессий, буферизация вывода, более безопасные способы обработки вводимой пользователем информации и несколько новых языковых конструкций.</p>      
    </div>
    </selection>
    <section class="review" id="review">
        <h2 class="review__heading">Обзор</h2>
        <div class="review__text">
            
            <p>
                Пятая версия PHP была выпущена разработчиками 13 июля 2004 года. Изменения включают обновление ядра Zend (Zend Engine 2), что существенно увеличило эффективность интерпретатора. Введена поддержка языка разметки XML. Полностью переработаны функции ООП, которые стали во многом схожи с моделью, используемой в Java. В частности, введён деструктор, открытые, закрытые и защищённые члены и методы, окончательные члены и методы, интерфейсы и клонирование объектов. В последующих версиях также были введены пространства имён, замыкания и целый ряд достаточно серьёзных изменений, количественно и качественно сравнимых с теми, которые появились при переходе на PHP 5.0.

Шестая версия PHP разрабатывалась с октября 2006 года[18]. Было сделано множество нововведений[19][20], как, например, исключение из ядра регулярных выражений POSIX и «длинных» суперглобальных массивов, удаление директив safe_mode, magic_quotes_gpc и register_globals из конфигурационного файла php.ini. Одним из основных новшеств должна была стать поддержка Юникода[21]. Однако в марте 2010 года разработка PHP6 была признана бесперспективной[22] из-за сложностей с поддержкой Юникода. Исходный код PHP6 перемещён на ветвь, а основной линией разработки стала версия 5.4.

PHP 7
В 2014 году было проведено голосование, по результатам которого следующая версия получила название PHP 7[23]. Выход новой версии планировался в середине октября 2015 года[24]. В марте 2015 года Zend представили инфографику, в которой описаны основные нововведения PHP 7[25].

3 декабря 2015 года было объявлено о выходе PHP версии 7.0.0[26].</p>

<figure class="review__php-icon">
    <img src="./img/logo.jpg" alt="reviwe__php-icon" class="img__2">
    <figcaption></figcaption>
</figure>

<p>

Новая версия основывается на экспериментальной ветви PHP, которая изначально называлась phpng (англ. PHP Next Generation «следующее поколение»), и разрабатывалась с упором на увеличение производительности и уменьшение потребления памяти[27]. В новой версии добавлена возможность указывать тип возвращаемых из функции данных[28], добавлен контроль передаваемых типов для данных[29], а также новые операторы.

13 июня 2019 вышла версия PHP 7.4. В ядро были добавлены типизированные свойства и стрелочные функции, а также ограниченная ковариация возвращаемого типа и контравариантность типа аргумента[30].

PHP 8
PHP версии 8.0 была выпущена 26 ноября 2020-го[31]. Главными нововведениями стали[32]: поддержка union-типов[33], JIT-компиляция[34] и атрибуты (также известны как аннотации), также «конструкция» switch была заменена на «выражение» match и был добавлен новый оператор Nullsafe.

9 июля 2020 года Дэйл Хирт (англ. Dale Hirt), менеджер проекта PHP в Microsoft, в рассылке php.internals выпустил сообщение[35] о том, что после выпуска версии PHP 8.0 Microsoft прекратит поддержку разработки этого языка программирования для Windows[36]. Специалисты Microsoft занимались компиляцией бинарных версий интерпретатора для ОС Windows и тестированием их безопасности. В сообществе разработчиков PHP сообщили, что примут все необходимые меры, чтобы найти в ближайшее время альтернативный вариант для организации поддержки PHP 8.0 и выше для Windows, например, своими силами[37]

            </p>
            <p>
                Ключевое слово class было зарезервировано ещё в третьей версии языка. В четвёртой версии стало возможно создавать классы и объекты на их основе. Однако принципы ООП поддерживались лишь частично, так например, все члены (переменные и методы) были открыты. К тому же создание объектов было дорогой операцией и работало медленно.

Начиная с пятой версии PHP обладает полной поддержкой ООП. Работа с классами была оптимизирована и теперь такой код работает достаточно быстро.

Класс в PHP объявляется с помощью ключевого слова class. Методы и свойства класса могут быть общедоступными (public, по умолчанию), защищёнными (protected) и скрытыми (private). PHP поддерживает все три основных механизма ООП — инкапсуляцию, полиморфизм подтипов и наследование (родительский класс указывается с помощью ключевого слова extends после имени класса). Поддерживаются интерфейсы (ставятся в соответствие с помощью implements). Разрешается объявление финальных, абстрактных методов и классов. Множественное наследование классов не поддерживается, однако класс может реализовывать несколько интерфейсов. Для обращения к методам родительского класса используется ключевое слово parent.

Начиная с версии 5.4.0 множественное наследование может быть реализовано с помощью механизма особенностей (англ. trait). Особенности похожи на примеси (англ. mixins), за исключением того что для них нельзя напрямую создать экземпляр. Повторное использование кода заключено в использовании кода особенности в нескольких классах. Допускается использовать в одном классе несколько особенностей. Механизм особенностей имеет средства разрешения конфликтов имён. При запуске программы код особенности будет «вкомпилирован» в код содержащего его класса.

Классы в PHP имеют ряд «магических» методов (англ. magic methods), начинающихся с двух символов подчёркивания — конструктор (__construct(), в версиях до 5.0 конструктором служил метод, одноимённый с классом) и деструктор (__destruct()), а также методы чтения (__get()) и записи (__set()), свёртывания (__sleep()) и развёртывания (__wakeup()), клонирования (__clone()) и др. Эти методы являются достаточно гибким инструментом: переопределяя их, можно добиться существенного изменения поведения объекта.

Все функции-члены реализованы виртуальными и потому все они являются методами.

Экземпляры класса создаются с помощью ключевого слова new, обращение к свойствам и методам объекта производится с использованием оператора ->. Для доступа к членам класса из его методов используется переменная $this.
            </p>
        </div>
    </section>
    <section class="code" id="code">
        <h2 class="code__heding">
            Пример кода
        </h2>
        <pre><code data-language="PHP" class="PHP__code">
            abstract class PHP_Token
{
    /**
     * @var string
     */
    protected $text;

    /**
     * @var int
     */
    protected $line;

    /**
     * @var PHP_Token_Stream
     */
    protected $tokenStream;

    /**
     * @var int
     */
    protected $id;

    /**
     * @param string           $text
     * @param int              $line
     * @param PHP_Token_Stream $tokenStream
     * @param int              $id
     */
    public function __construct($text, $line, PHP_Token_Stream $tokenStream, $id)
    {
        $this->text        = $text;
        $this->line        = $line;
        $this->tokenStream = $tokenStream;
        $this->id          = $id;
    }

    /**
     * @return string
     */
    public function __toString()
    {
        return $this->text;
    }

    /**
     * @return int
     */
    public function getLine()
    {
        return $this->line;
    }

    /**
     * @return int
     */
    public function getId()
    {
        return $this->id;
    }
}

abstract class PHP_TokenWithScope extends PHP_Token
{
    /**
     * @var int
     */
    protected $endTokenId;

    /**
     * Get the docblock for this token
     *
     * This method will fetch the docblock belonging to the current token. The
     * docblock must be placed on the line directly above the token to be
     * recognized.
     *
     * @return string|null Returns the docblock as a string if found
     */
    public function getDocblock()
    {
        $tokens            = $this->tokenStream->tokens();
        $currentLineNumber = $tokens[$this->id]->getLine();
        $prevLineNumber    = $currentLineNumber - 1;

        for ($i = $this->id - 1; $i; $i--) {
            if (!isset($tokens[$i])) {
                return;
            }

            if ($tokens[$i] instanceof PHP_Token_FUNCTION ||
                $tokens[$i] instanceof PHP_Token_CLASS ||
                $tokens[$i] instanceof PHP_Token_TRAIT) {
                // Some other trait, class or function, no docblock can be
                // used for the current token
                break;
            }

            $line = $tokens[$i]->getLine();

            if ($line == $currentLineNumber ||
                ($line == $prevLineNumber &&
                 $tokens[$i] instanceof PHP_Token_WHITESPACE)) {
                continue;
            }

            if ($line < $currentLineNumber &&
                !$tokens[$i] instanceof PHP_Token_DOC_COMMENT) {
                break;
            }

            return (string) $tokens[$i];
        }
    }
        </code>

        </pre>
    </section>
</div>
</header>
</body>